# 【回溯/DP】2024E-表演赛游戏分组
 
时间限制：C/C++ 1000MS，其他语言 2000MS
内存限制：C/C++ 128MB，其他语言 256MB
难度：中等
分数：100 OI排行榜得分：14(0.1*分数+2*难度)
出题人：

## 描述

部门准备举办一场王者荣耀表演赛，有 10 名游戏爱好者参与，分为两队，每队 5 人。 

每位参与者都有一个评分，代表着他的游戏水平。 

为了表演赛尽可能精彩，我们需要把 10 名参赛者分为实力尽量相近的两队。

一队的实力可以表示为这一队 5 名队员的评分总和。 

现在给你 10 名参与者的游戏水平评分，请你根据上述要求分队最后输出这两组的实力差绝对值。 

例: 10 名参赛者的评分分别为 5 1 8 3 4 6 7 10 9 2，分组为 (1 3 5 8 10) (2 4 6 7 9)，两组实力差最小，差值为 1。

有多种分法，但实力差的绝对值最小为 1。

### 输入描述

10 个整数，表示 10 名参与者的游戏水平评分。范围在[1,10000]之间

### 输出描述

1 个整数，表示分组后两组实力差绝对值的最小值。

### 用例输入 1 
```
1 2 3 4 5 6 7 8 9 10
```
### 用例输出 1 
```
1
```
### 用例说明 1 


## 解题思路
在这个问题中，我们通过深度优先搜索（DFS）尝试所有可能的分队方式，以找到实力差的绝对值最小的分队方案。整个算法的目标是遍历所有可能的组合，并计算出两队实力差的最小绝对值。

这里使用的深度优先搜索算法中，每一步都有两种选择：将当前玩家分配给第一队，或者不分配给第一队（即默认分配给第二队）。这样的策略保证了覆盖所有可能的分队方式。

解释代码段

```
// 为第一个队伍选择当前玩家
dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);
        
// 不为第一个队伍选择当前玩家
dfs(nums, idx + 1, count, currentSum);
```
这两行代码是DFS递归的核心，它们代表了在每一步有两种选择：

选择当前玩家加入第一队：这是通过`dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);`实现的。这里`idx + 1`表示考虑下一个玩家，`count + 1`表示第一队的玩家数增加了1，`currentSum + nums[idx]`表示第一队的总评分增加了当前玩家的评分。

不选择当前玩家加入第一队：即留给第二队，通过`dfs(nums, idx + 1, count, currentSum);`实现。这里只将idx增加1，移动到下一个玩家，而count和currentSum保持不变，因为没有新的玩家加入第一队。

### 整体逻辑
初始时，totalSum计算了所有玩家的评分总和，targetSum是总和的一半。这是因为我们的目标是使两队的评分尽可能接近`totalSum / 2`。
通过DFS尝试所有可能的分队方式，每次递归都有两种选择：将当前玩家加入第一队或不加入。
当一个队伍选满5名玩家时，计算两队的评分差，并更新最小差值res。
继续递归直到所有玩家都被考虑过，最终res会是实力差的最小绝对值。
### 剪枝优化
注释中提到的剪枝条件if (currentSum > targetSum) return;， 经过考友的反馈，去掉的话是100%的通过率，请各位机考时都加上去试试。