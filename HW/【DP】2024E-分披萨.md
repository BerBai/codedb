# 【DP】2024E-分披萨
 
时间限制：C/C++ 1000MS，其他语言 2000MS
内存限制：C/C++ 128MB，其他语言 256MB
难度：中等
出题人：

## 描述

“吃货”和“馋嘴”两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数扇形小块。但是粗心服务员将技萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。 

由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从“吃货”开始，轮流取披萨。

除了第一块披萨可以任意选取以外，其他都必须从缺口开始选。他俩选披萨的思路不同。 

“馋嘴”每次都会选最大块的披萨，而且“吃货"知道“馋嘴”的想法。 

已知披萨小块的数量以及每块的大小，求“吃货”能分得的最大的披萨大小的总和。

### 输入描述

第1行为一个正整数奇数N，表示披萨小块数量。3 <= N <= 500。 

接下来的第2行到第N+1行(共N行)，每行为一个正整数，表示第ì块披萨的大小。1 <= i <= N。 

披萨小块从某一块开始，按照一个方向依次顺序编号为1~N。每块披萨的大小范围为[1,21474836471]。

### 输出描述

“吃货”能分得的最大的披萨大小的总和。

### 用例输入 1 
```
5
8
2
10
5
7
```
### 用例输出 1 
```
19
```
### 用例说明 1 

此例子中，有 5 块披萨。每块大小依次为 8、2、 10、5、7。 
按照如下顺序拿披萨，可以使”吃货"拿到最多披萨： 
“吃货” 拿大小为 10 的披萨 
“馋嘴” 拿大小为 5 的披萨 
“吃货” 拿大小为 7的披萨 
“馋嘴” 拿大小为 8 的披萨 
“吃货” 拿大小为 2 的披萨 
至此，披萨瓜分完毕，“吃货”拿到的披萨总大小为 10+7+2＝19 
可能存在多种拿法， 以上只是其中一种。 

## 解题思路
记忆化搜索：定义一个递归函数 f(l, r, t) 来表示从区间 [l, r] 里，“吃货”能分得的最大披萨大小的总和。这里 l 和 r 分别表示区间的左边界和右边界，t 表示剩余的次数。
贪心选择：每次“馋嘴”都会选择当前区间内最大的披萨块，这会影响到下一步“吃货”的选择。因此，我们需要在“吃货”选择之前模拟“馋嘴”的贪心选择，以确保“吃货”能得到最大总和。
递归处理：递归地缩小问题规模，通过模拟“吃货”在每一步的选择，并记录下最优结果。
## 代码描述
输入处理：读取输入的披萨块数量 n 和每块披萨的大小。
缓存优化：使用 functools.cache 来缓存递归结果，避免重复计算。
递归函数 f：
参数：l 为左边界，r 为右边界，t 为剩余次数。
基本情况：如果剩余次数 t 小于等于1，则返回0。
贪心选择：模拟“馋嘴”选择当前区间内的最大披萨块，更新 l 或 r。
动态规划选择：计算“吃货”选择左边界 l 或右边界 r 时的最大总和，并返回其中较大的值。
主逻辑：通过遍历每块披萨，计算“吃货”从该块披萨开始能得到的最大总和。
