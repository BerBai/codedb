# 【位运算】2024E-分苹果
 
时间限制：C/C++ 1000MS，其他语言 2000MS
内存限制：C/C++ 128MB，其他语言 256MB
难度：简单
出题人：

## 描述

A，B两团体想把苹果分为两堆。 

A盼望依照它的计算规则平分苹果，他的计算是依照二进制加法进行计算，而且不计算进位。 

以12 + 5为例，按照A的计算规则有12 + 5 = bin(1100) + bin(0101) = bin(1001) = 9 成立。 

B的计算是最常见的十进制加法，包含进位。B期望在满足A的情形下获取苹果分量最多。 

输入苹果的数目跟每个苹果的重量，输出满意A的情形下获取的苹果总重量；假如无法满意A的请求，输出-1。 输入描述

### 输入描述

苹果的数目跟每个苹果分量

### 输出描述

B在满意A的情形下获取的苹果总分量，假如B无法满意A的请求，输出-1。

### 用例输入 1 
```
3
3 5 6
```
### 用例输出 1 
```
11
```

## 解题思路

想清楚这一点！非常重要！！

首先，如果能满足 A，那么所有苹果全部 “异或”操作后，必然是0 。

为什么呢？ 假设 第一堆苹果有 x个， 第二堆有y个， 那么 前面x个数的 异或 结果 ， 必然等于 后面y个数的异或结果。

异或是 ^ 这个符号，我们假设 x= 4， y = 6 ，那么有：

设

x = x1^x2^x3^x4

y = y1^y2^y3^y4^y5^y6 ,

既然是满足A的要求，所以 x == y ；

既然x == y ，那么它们转为二进制后，一定是一模一样，每一位都一样，而异或就是，这一位相同，则结果是0，这一位不同，则结果是1.

显然， x^y = 0;



其次，要想 B 最多，只需要将这堆苹果中，最小的一个给A即可。因为所有苹果异或的结果是0，所以任意拿出1个，分成另一堆， 那么这两堆的重量，

按照A的算法去算，必然是相等的。