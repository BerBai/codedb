# 【回溯】2024E-字符串拼接
 
时间限制：C/C++ 1000MS，其他语言 2000MS
内存限制：C/C++ 128MB，其他语言 256MB
难度：中等
分数：100 OI排行榜得分：14(0.1*分数+2*难度)
出题人：

## 描述

给定M (0<M<=30)个字符(a-z)，从中取出任意字符(每个字符只能用一次)拼接成长度为N (0<N<=5)的字符串，要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串，输入非法或者无法拼接出满足条件的字符串则返回0。
### 输入描述

给定的字符列表和结果字符串长度，中间使用空格(" ")拼接

### 输出描述

满足条件的字符串个数

### 用例输入 1 
```
aabc 3
```
### 用例输出 1 
```
8
```
### 用例说明 1 

给定的字符为aabc，结果字符串长度为3，可以拼接成abc,acb,bac,bca,cba,cab,aba,aca，共8种

### 用例输入 2 
```
abc 3
```
### 用例输出 2 
```
1
```
### 用例说明 2 

给定的字符为abc，结果字符串长度为1，可以拼接成a,b,c，共3种

## 解题思路
使用递归和回溯的思想来生成不同的字符串。具体的逻辑如下：

首先，我们定义一个函数generateDistinctStrings，这个函数接收以下参数：可用字符集s，目标字符串长度length，当前已生成的字符串current，已生成的结果集result，以及一个标记数组used，用来记录每个字符是否已被使用。

在generateDistinctStrings函数中，首先检查当前已生成的字符串current的长度是否等于目标长度length。如果等于，说明我们已经生成了一个满足长度要求的字符串，将其添加到结果集result中，然后返回。

如果当前字符串current的长度还未达到目标长度length，我们就需要继续添加字符。此时，我们遍历可用字符集s中的每一个字符。对于每一个字符，我们首先检查它是否已经被使用（通过查看used数组），以及它是否与current的最后一个字符相同。如果字符已经被使用，或者与current的最后一个字符相同，我们就跳过这个字符，继续检查下一个字符。

如果一个字符未被使用，且与current的最后一个字符不同，我们就将它添加到current的末尾，然后标记这个字符为已使用，接着递归调用generateDistinctStrings函数，以生成下一个字符。

在递归调用返回后，我们需要取消对当前字符的使用标记，以便在后续的遍历中可以再次使用这个字符。这就是回溯的思想，即撤销之前的选择，尝试其他的选择。

以下是对应的中文伪代码：
```
函数 generateDistinctStrings(s, length, current, result, used)
    如果 current的长度 等于 length
        将 current 添加到 result
        返回
    对于 s中的每一个字符 c
        如果 c已被使用 或者 c与current的最后一个字符相同
            继续下一次循环
        标记 c为已使用
        generateDistinctStrings(s, length, current + c, result, used)
        取消标记 c的使用状态
```

## 解题思路2
本题数据量不大，虽然只是要求枚举数量而不是枚举具体的字符串，但仍然可以通过回溯来解决。

注意到在本题中，原输入字符串s中的字符顺序并不重要，只有出现次数是关键信息。

所以很容易考虑应该使用哈希表计数器来统计s中各个字符出现的次数。即
```
cnt = Counter(s)
```
回溯的重点在于回溯函数的编写。函数传参需要包含三个参数：

- n：目标字符串的长度
- path：当前所选择的路径字符串的情况
- cnt：原字符串s中的字符剩余情况

考虑递归终止条件，显然当len(path) == n时，我们找到了一个长度为n的拼接字符串，更新ans并退出递归，即
```
global ans
if len(path) == n:
    ans += 1
    return
```
考虑横向遍历过程，我们需要考虑cnt中的所有key以及这些key的value。当

- value == 0时，说明key这个字符已经在之前被选择过了，无法再选
- (path and key == path[-1])时，说明此时key和当前path的最后一个字符一致，此时是不能够选择key延长在path的后面的。
对于上述两种情况，都可以直接跳过该(key, value)对。

当不满足上述情况时，则可以进行状态更新和回溯，以及回溯结束后的回滚操作。即
```
for k, v in cnt.items():
    if v == 0 or (path and k == path[-1]):
        continue
    cnt[k] -= 1
    dfs(cnt, path + k, n)
    cnt[k] += 1
```
综上整体的回溯函数为
```
def dfs(cnt, path, n):
    global ans
    if len(path) == n:
        ans += 1
        return
    for k, v in cnt.items():
        if v == 0 or (path and k == path[-1]):
            continue
        cnt[k] -= 1
        dfs(cnt, path + k, n)
        cnt[k] += 1
```
这就完成了本题的核心递归函数。

至于递归入口，则传入path = ""即可。

另外题目说明当出现非法输入时需要返回0，因此还需要判断s中的每一个字符是否均为小写字符。