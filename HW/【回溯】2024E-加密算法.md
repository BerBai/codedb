# 【回溯】2024E-加密算法
 
时间限制：C/C++ 1000MS，其他语言 2000MS
内存限制：C/C++ 128MB，其他语言 256MB
难度：中等
出题人：

## 描述

有一种特殊的加密算法，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。规则如下

1. 明文为一段数字串由0-9组成 

2. 密码本为数字0-9组成的二维数组 

3. 需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意:对角线不相邻，同一个单元格的数字不能重复使用。 

4. 每一位明文对应密文即为密码本中找到的单元格所在的行和列序号(序号从0开始)组成的两个数字。如明文第i位Data[i]对应密码本单元格为Book[X][Y]，则明文第i位对应的密文为X Y，X和Y之间用空格隔开。

如果有多条密文，返回字符序最小的密文。如果密码本无法匹配，返回"error". 请你设计这个加密程序。


示例 1:
密码本:
```
{0,0,2},
{1,3,4},
{6,6,4}
```
明文"3"，密文"1 1"

示例 2:
密码本:
```
{0,0,2},
{1,3,4},
{6,6,4}
```
明文"0 3",密文"0 1 1 1"

示例 3:
密码本:
```
{0,0,2,4}
{1,3,4,6}
{3,4,1,5}
{6,6,6,5}
```
明文"0 0 2 4"，密文"0 0 0 1 0 2 0 3"和"0 0 0 1 0 2 1 2"，返回字典序小的"0 0 0 1 0 2 0 3"


### 输入描述

第一行输入1个正整数N，代表明文的长度(1 <= N <= 9) 

第二行输入N个明文数字组成的序列Data[i](整数，0 <= Data[i] <= 9) 

第三行输入1个正整数M，(1 <= M <= 9) 

接下来输入一个M*M的矩阵代表密码本Book[i][i]，(整数，0 <= Book[i][i] <= 9)

### 输出描述

如明文 第i位Data[i]对应密码本单元格为Book[i][j]，则明文第i位对应的密文为X Y，X和Y之间用空格隔开。如果有多条密文，返回字符序最小的密文。如果密码本无法匹配，返回"error"。

### 用例输入 1 
```
4
0 0 2 4
4
0 0 2 4
1 3 4 6
3 4 1 5
6 6 6 5
```
### 用例输出 1 
```
0 0 0 1 0 2 0 3
```
### 用例说明 1 

## 解题思路
注意，本题和 [LeetCode79.单词搜索](https://leetcode.cn/problems/word-search/)、2024E.找到它 非常类似。唯一的区别是，题目不保证答案是唯一的，当存在多个合适的密文的时候，需要返回字典序最小的那个。

本题基本思路和 2024E.找到它 一致。本题需要着重考虑最小字典序的问题。

这个时候，搜索的方向数组DIRECTIONS里的顺序就非常重要了。假设当前点为(x, y)，那么其近邻点为

上方：(x-1, y)
左方：(x, y-1)
右方：(x, y+1)
下方：(x+1, y)
显然，如果存在多个近邻点同时满足下一个字符的时候，按照上、左、右、下这个顺序来搜索的话，一定能够得到最小的字典序，因为坐标为更小字典序的近邻点被优先搜索了。

这也是极少数的，我们需要特别注意方向数组DIRECTIONS的顺序的题目。即
```
DIRECTIONS = [(-1, 0), (0, -1), (0, 1), (1, 0)]
```
